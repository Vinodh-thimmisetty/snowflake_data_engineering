CREATE OR REPLACE TRANSIENT TABLE DUMMY.TMP.SALES (
    SALE_ID NUMBER AUTOINCREMENT,
    PRICE NUMBER,
    ORDER_DATE TIMESTAMP DEFAULT CURRENT_TIMESTAMP()
);

CREATE OR REPLACE TRANSIENT TABLE DUMMY.TMP.SALES_2 (
    SALE_ID NUMBER AUTOINCREMENT,
    PRICE NUMBER,
    ORDER_DATE TIMESTAMP
);

CREATE OR REPLACE TRANSIENT TABLE DUMMY.TMP.SALES_3 (
    SALE_ID NUMBER AUTOINCREMENT,
    PRICE NUMBER,
    ORDER_DATE TIMESTAMP
);


CREATE OR REPLACE PROCEDURE PURCHASE_PRODUCT(ORDER_AMOUNTS ARRAY)
RETURNS TEXT
LANGUAGE SQL
EXECUTE AS CALLER
AS
DECLARE
    TOTAL_ORDERS INT DEFAULT 0;
BEGIN
    FOR I IN 0 TO ARRAY_SIZE(:ORDER_AMOUNTS) - 1 DO
        -- LET CURRENT_VALUE NUMBER := GET(:ORDER_AMOUNTS, :I);
        -- INSERT INTO DUMMY.TMP.SALES(PRICE) VALUES (GET(:ORDER_AMOUNTS, :I));
        INSERT INTO DUMMY.TMP.SALES_2(PRICE, ORDER_DATE) SELECT GET(:ORDER_AMOUNTS, :I), CURRENT_TIMESTAMP();
        TOTAL_ORDERS := TOTAL_ORDERS + 1;
    END FOR;
    RETURN 'Successfully processed ' || TOTAL_ORDERS || ' orders';
END;
call PURCHASE_PRODUCT(ARRAY_CONSTRUCT(100, 200, 300));
call PURCHASE_PRODUCT(ARRAY_CONSTRUCT(400, 'ABC', '500'));
-- View the results
SELECT * FROM DUMMY.TMP.SALES;
SELECT * FROM DUMMY.TMP.SALES_2;


CREATE OR REPLACE PROCEDURE PURCHASE_PRODUCT_BATCH(ORDER_AMOUNTS ARRAY)
RETURNS TEXT
LANGUAGE SQL
EXECUTE AS CALLER
AS
DECLARE
    TOTAL_ORDERS INT DEFAULT 0;
BEGIN
    INSERT INTO DUMMY.TMP.SALES_3(PRICE, ORDER_DATE)
    SELECT VALUE, CURRENT_TIMESTAMP()
    FROM TABLE(FLATTEN(INPUT => :ORDER_AMOUNTS));
    TOTAL_ORDERS := ARRAY_SIZE(:ORDER_AMOUNTS);
    RETURN 'Successfully processed ' || TOTAL_ORDERS || ' orders';
END;
call PURCHASE_PRODUCT_BATCH(ARRAY_CONSTRUCT(100, 200, 300));
call PURCHASE_PRODUCT_BATCH(ARRAY_CONSTRUCT(400, 'ABC', '500'));

SELECT * FROM DUMMY.TMP.SALES_3;


CREATE OR REPLACE TRANSIENT TABLE DUMMY.TMP.SALES_STRICT (
    SALE_ID NUMBER AUTOINCREMENT,
    PRICE NUMBER,
    ORDER_DATE TIMESTAMP DEFAULT CURRENT_TIMESTAMP()
);

CREATE OR REPLACE TRANSIENT TABLE DUMMY.TMP.SALES_STRICT2 (
    SALE_ID NUMBER AUTOINCREMENT,
    PRICE NUMBER,
    ORDER_DATE TIMESTAMP
);

CREATE OR REPLACE PROCEDURE PURCHASE_PRODUCT_STRICT(ORDER_AMOUNTS ARRAY)
RETURNS TEXT
LANGUAGE SQL
EXECUTE AS CALLER
AS
DECLARE
    TOTAL_ORDERS INT DEFAULT 0;
BEGIN

    BEGIN TRANSACTION;
    FOR I IN 0 TO ARRAY_SIZE(:ORDER_AMOUNTS) - 1 DO
        -- LET CURRENT_VALUE NUMBER := GET(:ORDER_AMOUNTS, :I);
        -- INSERT INTO DUMMY.TMP.SALES(PRICE) VALUES (GET(:ORDER_AMOUNTS, :I));
        INSERT INTO DUMMY.TMP.SALES_STRICT2(PRICE, ORDER_DATE) SELECT GET(:ORDER_AMOUNTS, :I), CURRENT_TIMESTAMP();
        TOTAL_ORDERS := TOTAL_ORDERS + 1;
    END FOR;
    COMMIT;
    RETURN 'Successfully processed ' || TOTAL_ORDERS || ' orders';
    EXCEPTION
  WHEN STATEMENT_ERROR THEN
    -- This block is executed on any statement error

    LET error_message := 'Transaction failed. ' || CURRENT_TRANSACTION();
    ROLLBACK; -- Explicitly roll back the entire transaction
    RETURN error_message; -- Provide a clear message

END;
call PURCHASE_PRODUCT_STRICT(ARRAY_CONSTRUCT(100, 200, 300));
call PURCHASE_PRODUCT_STRICT(ARRAY_CONSTRUCT(400, 'ABC', '500'));

SELECT * FROM DUMMY.TMP.SALES_STRICT;
SELECT * FROM DUMMY.TMP.SALES_STRICT2;

SHOW TRANSACTIONS;
SHOW LOCKS;

SHOW TRANSACTIONS IN ACCOUNT;

SELECT CURRENT_TRANSACTION();

SELECT
    query_id,
    query_text,
    transaction_id
FROM
    snowflake.account_usage.query_history
WHERE
    query_id = '01bef061-0000-3129-0048-710b001aa54e';
 